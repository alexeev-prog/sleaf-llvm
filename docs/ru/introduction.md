# RU: Система генерации кода SLEAF на LLVM - Исчерпывающая техническая документация

Данная документация предоставляет глубокий анализ **примера** реализации LLVM-бэкенда компилятора SLEAF, детально описывая каждое архитектурное решение, конструкцию кода и взаимодействие с LLVM. Написанная для инженеров-компиляторщиков, ищущих глубокого понимания, она сочетает повествовательные объяснения с технической точностью, освещая как "как", так и "почему" генерации кода на основе LLVM.

---

## Архитектурный фундамент и экосистема компонентов

В основе компилятора SLEAF лежит тщательно выстроенная иерархия компонентов LLVM, которые управляют трансляцией из конструкций высокоуровневого языка в оптимизированный машинный код. Архитектура системы вращается вокруг трех фундаментальных столпов, формирующих основу её возможностей генерации кода.

**1. LLVM Context: Изолированная камера**  
`llvm::LLVMContext` служит основой процесса компиляции, создавая песочницу, которая предотвращает коллизии типов и обеспечивает потокобезопасность. При инициализации через `std::make_unique<llvm::LLVMContext>()` этот компонент устанавливает виртуальное рабочее пространство, где вся информация о типах, константах и метаданных существует в полной изоляции от других единиц компиляции. Эта изоляция становится особенно важной в многопоточных сценариях компиляции, где отдельные контексты позволяют параллельную обработку без накладных расходов на синхронизацию. Система типов контекста гарантирует строгую уникальность - два типа i32, созданные в разных контекстах, остаются различными сущностями, предотвращая случайные несоответствия типов в сложных конвейерах компиляции.

**2. IR Module: Репозиторий кода**  
`llvm::Module` действует как журнал компилятора, фиксирующий каждую функцию, глобальную переменную и узел метаданных. Его создание через `std::make_unique<llvm::Module>("SLEAFModule", *context)` формирует именованный контейнер, существующий на протяжении всего сеанса компиляции. Рассмотрим модуль, содержащий простую функцию main:

```llvm
; ModuleID = 'SLEAFModule'
source_filename = "SLEAFModule"

define i32 @main() {
entry:
  ret i32 42
}
```

Это текстовое представление демонстрирует роль модуля как корневого контейнера для всего сгенерированного IR. Внутренне модуль поддерживает несколько критически важных структур данных:
- **Список функций**: Содержит все определения функций
- **Таблица глобальных переменных**: Хранит данные, доступные между функциями
- **Реестр метаданных**: Содержит информацию для отладки и оптимизации
- **Таблица символов**: Обеспечивает эффективное разрешение имен

**3. IRBuilder: Рабочая лошадка генерации кода**  
Класс `llvm::IRBuilder<>` функционирует как движок генерации кода, предоставляя удобный интерфейс для построения инструкций LLVM IR. Инициализированный через `std::make_unique<llvm::IRBuilder<>>(*context)`, этот компонент управляет несколькими критическими аспектами процесса генерации кода:

- **Состояние вставки инструкций**: Отслеживает текущую позицию внутри базовых блоков
- **Интеграция системы типов**: Автоматически управляет преобразованиями типов
- **Управление SSA-значениями**: Гарантирует соответствие форме статического одиночного присваивания
- **Отладочная информация**: Опциональная интеграция с метаданными отладки

Типичная последовательность генерации инструкций демонстрирует возможности билдера:

```cpp
// Создание 32-битной целочисленной константы
llvm::Value* baseValue = builder->getInt32(40);

// Генерация арифметической операции
llvm::Value* sum = builder->CreateAdd(
    baseValue,
    builder->getInt32(2),
    "result"  // Опциональное имя значения
);

// Создание инструкции возврата
builder->CreateRet(sum);
```

Эта последовательность производит следующий IR-вывод:

```llvm
define i32 @main() {
entry:
  %result = add i32 40, 2
  ret i32 %result
}
```

---

## Конвейер генерации функций

Создание функций LLVM следует строгому многоэтапному процессу, гарантирующему согласованность типов и валидность IR. Рассмотрим полный жизненный цикл генерации функции через расширенный анализ кода.

### Создание прототипа функции
```cpp
llvm::Function* createFunctionProto(const std::string& name,
                                   llvm::FunctionType* type) {
    auto* func = llvm::Function::Create(
        type,
        llvm::Function::ExternalLinkage,
        name,
        module.get()
    );
    verifyFunction(*func);
    return func;
}
```

**Этап 1: Спецификация типа**  
Метод `llvm::FunctionType::get` устанавливает сигнатуру функции. Для функции main, возвращающей i32:

```cpp
llvm::FunctionType* funcType = llvm::FunctionType::get(
    builder->getInt32Ty(), // Тип возвращаемого значения
    {},                    // Типы параметров (пусто)
    false                  // Без вариативных аргументов
);
```

**Этап 2: Создание функции**  
Метод `Function::Create` выполняет несколько критических операций:
1. **Регистрация символа**: Добавляет функцию в таблицу символов модуля
2. **Конфигурация линковки**: `ExternalLinkage` делает функцию видимой для внешних линкеров
3. **Привязка типа**: Связывает функцию с предопределенным типом
4. **Назначение родителя**: Связывает функцию с содержащим модулем

**Этап 3: Валидация IR**  
Вызов `verifyFunction` выполняет комплексные проверки:
- Согласованность типов параметров
- Валидность типа возвращаемого значения
- Целостность базовых блоков
- Наличие терминаторных инструкций

### Генерация тела функции
```cpp
void prepareFunctionBody(llvm::Function* func) {
    llvm::BasicBlock* entry = llvm::BasicBlock::Create(
        *context,   // Привязанный контекст
        "entry",     // Метка блока
        func         // Родительская функция
    );
    builder->SetInsertPoint(entry);
}
```

**Требования к базовым блокам**:
1. **Единственная точка входа**: Функции должны содержать ровно один стартовый блок
2. **Обязательность терминатора**: Все блоки должны заканчиваться инструкциями управления потоком
3. **Уникальность меток**: Имена блоков должны быть уникальны в пределах функции

**Управление точкой вставки**:  
Метод `SetInsertPoint` направляет последующие инструкции в указанный блок. Этот подход с сохранением состояния позволяет гибкие шаблоны генерации кода:

```cpp
// Генерация пролога
builder->SetInsertPoint(entryBlock);
generatePrologue();

// Генерация основной логики
builder->SetInsertPoint(mainBlock);
generateMainLogic();

// Генерация эпилога
builder->SetInsertPoint(exitBlock);
generateEpilogue();
```

---

## Генерация значений и управление SSA

Компилятор строго соблюдает форму статического одиночного присваивания (SSA) через систематическое управление значениями. Рассмотрим расширенный пример генерации значений:

```cpp
llvm::Value* generateComplexExpression() {
    // Создание базового значения
    llvm::Value* base = builder->getInt32(100);
    
    // Генерация цепочки вычислений
    llvm::Value* intermediate = builder->CreateMul(
        base,
        builder->getInt32(2),
        "intermediate"
    );
    
    llvm::Value* finalResult = builder->CreateAdd(
        intermediate,
        builder->getInt32(20),
        "final"
    );
    
    return finalResult;
}
```

**Вывод в форме SSA**:
```llvm
define i32 @main() {
entry:
  %intermediate = mul i32 100, 2
  %final = add i32 %intermediate, 20
  ret i32 %final
}
```

**Механизмы обеспечения SSA**:
1. **Автоматическая нумерация значений**: Каждый вызов IRBuilder генерирует новые виртуальные регистры
2. **Неизменяемые значения**: После создания значения не могут изменяться
3. **Отслеживание доминации**: Билдер гарантирует объявление значений перед использованием

**Система безопасности типов**:
```cpp
llvm::Value* floatValue = builder->getFloat(3.14f);
llvm::Value* intValue = builder->getInt32(42);

// Это вызовет ошибку компиляции:
llvm::Value* invalid = builder->CreateAdd(floatValue, intValue);
```

Система типов IRBuilder предотвращает несовместимые операции через проверки RTTI (информации о типах во время выполнения), отлавливая несоответствия типов во время компиляции, а не верификации.

---

## Управление памятью и интеграция с C++

Реализация использует современные возможности C++ для обеспечения надежного управления ресурсами при сохранении высокой производительности.

### Стратегия умных указателей
```cpp
std::unique_ptr<llvm::LLVMContext> context;
std::unique_ptr<llvm::Module> module;
std::unique_ptr<llvm::IRBuilder<>> builder;
```

**Иерархия владения**:
- **Контекст** владеет модулем через ссылку
- **Модуль** владеет функциями и глобальными переменными
- **IRBuilder** поддерживает временное состояние генерации

**Преимущества**:
- Автоматическое освобождение ресурсов
- Четкая семантика владения
- Безопасность при исключениях
- Предотвращение висячих указателей

### Вывод типов и безопасность
```cpp
auto* functionType = llvm::FunctionType::get(
    builder->getInt32Ty(),
    {builder->getDoubleTy()},
    false
);
```

**Обоснование использования auto**:
- Сокращает многословие со сложными типами LLVM
- Сохраняет статическую проверку типов
- Улучшает сопровождаемость кода

**Интеграция системы типов**:
Иерархия типов LLVM автоматически управляется через контекст:
```cpp
// Получение распространенных типов
llvm::Type* voidTy = llvm::Type::getVoidTy(*context);
llvm::Type* intPtrTy = llvm::Type::getInt8PtrTy(*context);
```

---

## Разбивка процесса компиляции

### Фаза 1: Инициализация
Жизненный цикл компиляции начинается с тщательного выделения ресурсов:

```cpp
void moduleInit() {
    // 1. Создание контекста - основа для всех компонентов
    context = std::make_unique<llvm::LLVMContext>();
    
    // 2. Инициализация модуля - именованная единица компиляции
    module = std::make_unique<llvm::Module>(
        "SLEAFCompilation", 
        *context
    );
    
    // 3. Настройка IRBuilder - готов к генерации инструкций
    builder = std::make_unique<llvm::IRBuilder<>>(*context);
}
```

**Критическая последовательность**:
1. **Контекст первым**: Требуется всеми последующими компонентами
2. **Модуль вторым**: Требует ссылку на контекст для создания типов
3. **Билдер последним**: Требует установленную систему типов

### Фаза 2: Генерация IR
Основной процесс трансляции разворачивается через методичные шаги:

```cpp
void generateIR() {
    // 1. Разрешение типа функции
    llvm::FunctionType* mainType = llvm::FunctionType::get(
        builder->getInt32Ty(),
        {},
        false
    );
    
    // 2. Объявление функции
    activeFunction = createFunction("main", mainType);
    
    // 3. Генерация значений
    llvm::Value* result = generateExpression();
    
    // 4. Завершение инструкций
    builder->CreateRet(result);
}
```

**Нюансы генерации кода**:
- **Разрешение типов**: Явная спецификация предотвращает неявные преобразования
- **Создание функции**: Комбинирует прототип и генерацию тела
- **Жизненный цикл значений**: Временные значения остаются валидными через отслеживание SSA
- **Требование завершения**: Блоки должны заканчиваться инструкциями ret/br

### Фаза 3: Вывод и верификация
Финальная стадия обеспечивает валидность IR и производит несколько форматов вывода:

```cpp
void saveModuleToFile(const std::string& filename) {
    std::error_code ec;
    llvm::raw_fd_ostream outStream(filename, ec);
    module->print(outStream, nullptr);
}
```

**Соображения вывода**:
- **raw_fd_ostream**: Оптимизирован для больших дампов IR
- **Обработка ошибок**: Система error_code LLVM перехватывает проблемы ввода-вывода
- **Форматы вывода**: Текстовый IR, Bitcode или прямое создание объектных файлов

---

## Продвинутые концепции LLVM

### Управление метаданными
Система может быть расширена отладочной информацией:

```cpp
llvm::DIBuilder diBuilder(*module);
auto diFile = diBuilder.createFile("main.mlang", "src/");
auto diType = diBuilder.createBasicType("int", 32, llvm::dwarf::DW_ATE_signed);
```

**Интеграция отладки**:
- Отслеживание местоположения переменных
- Сохранение информации о строках исходного кода
- Включение отладки на уровне исходного кода

### Интеграция конвейера оптимизаций
Точки будущего расширения включают:

```cpp
llvm::PassManager pm;
pm.add(llvm::createPromoteMemoryToRegisterPass());
pm.add(llvm::createInstructionCombiningPass());
pm.run(*module);
```

**Стратегии оптимизации**:
- Mem2Reg: Преобразование переменных стека в регистры
- Упрощение CFG: Очистка управления потоком
- Удаление мертвого кода: Устранение неиспользуемых инструкций

---

Данная документация предоставляет беспрецедентно глубокое погружение в реализацию LLVM-бэкенда SLEAF, предлагая исчерпывающие технические детали при сохранении удобочитаемости. Сочетая теоретические объяснения с практическими примерами кода, она служит как образовательным ресурсом, так и практическим справочником для инженеров-компиляторщиков, работающих с инфраструктурой LLVM. Архитектура демонстрирует лучшие практики современной разработки компиляторов на C++, сохраняя гибкость для будущих расширений.
