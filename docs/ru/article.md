# Как создать свой нетипичный язык программирования (на примере C++ И llvm)?
Приветствую всех в новой моей статье. Еще давно я интересовался языками программирования и компиляторами, всегда было желание создать свой just-for-fun язык (или даже что-то большее) - но не хватало знаний.

И вот, спустя N времени, я решился. За основу я взял C++ - данный выбор обусловлен выбором LLVM в качестве бекенда компилятора, а также наличие полезного функционала (среди которых я могу выделить ООП, как самое заметное).

В этой статье я хочу поведать о том, как я создавал компилятор моего языка, с какими проблемами сталкивался, как создавал синтаксис языка, а также как настраивал окружение для работы.

Будет несколько глав - в этой части я расскажу о самом LLVM, об устройстве компиляторов, о построении синтаксиса и других насущных вещах, такое как окружение для работы, утилиты, план работы.

Здесь я попытался выделить те моменты, с которыми не встречался в других статьях, или они были раскрыты недостаточно хорошо. Кроме того, здесь я выскажу свое мнение о том, как можно реализовать некоторые конструкции, принести нотку оригинальности в язык. Я попытаюсь не копировать созданный функционал, а размышлять, каким он может быть еще. Что, если отвергнуть традиционный подход, или подойти с другой стороны к решению проблемы?

---

# Что есть язык программирования?
Начнем с простейшего. Что такое язык программирования? По сути, это язык со своей лексикой и грамматикой, созданный для решения алгоритмов на высоком уровне. Конструктор, позволяющий строить и соединять сложные цепочки. Одним словом — решать проблемы.

В программировании есть парадигмы; каждая из них создана для решения конкретной задачи. На данный момент их две, и каждая имеет свои направления.

Начнем с императивной парадигмы. Это самый распространенный подход, где мы точно говорим, что будем делать. Последовательное выполнение заданных действий. Используя ее, мы точно знаем, что будет совершено. Но это не значит, что весь результат будет известен заранее, ведь действия могут интерпретироваться по-разному в зависимости от предпринятых шагов.

Императивное программирование имеет следующие направления:

1. Процедурное — Императивное программирование развивалось как процедурное, где основное понятие — это функция. Функция, или процедура, — это последовательность действий, которые записали и назвали. Самый ближайший пример — язык C.
2. ООП — великое и ужасное, объектно-ориентированное программирование. В этом подходе появляются объекты, которые сами выполняют функции. Мы обязательно затронем эту тему еще раз, когда будем создавать ООП в нашем языке. Заранее стоит сказать, что современное ООП является точкой конфликта многих программистов. Многие даже до конца не знают, что такое ООП, ведь это определение весьма расплывчатое. Оно плотно ассоциируется с классами, но ООП может существовать и без них. Также Алан Кей, создатель данной парадигмы, говорил, что нынешний подход к ООП — не совсем верный. В будущем мы рассмотрим обе позиции — и ставшую ныне традиционной, и альтернативный подход. А о самом ООП вы можете найти множество статей-рассуждений на том же Хабре.
3. Кроме этого можно упомянуть структурное и модульное программирование. В структурной парадигме вводят новые понятия, объединяющие часто используемые шаблоны написания императивного кода. Вводится понятие составной инструкции (блока), инструкций ветвления и цикла. Программа, описанная в стиле модульного программирования, — это набор модулей. Модуль — это отдельная именованная сущность программы, которая объединяет в себе другие программные единицы, близкие по функциональности. Впрочем, оба направления сейчас считаются "забытыми".

Перейдем к более непопулярному, а соответственно, и интересному — декларативному программированию (которое, кстати, уже начинает интересовать многих людей).

Декларативная парадигма требует от программиста ответа на вопрос «что должно получиться?», а не «что нужно сделать?». То есть мы объявляем конечный результат. Здесь уже может возникнуть проблема в том, что при неясном описании нужного нам продукта действий, эти самые действия также остаются неизвестными и могут становиться неочевидными. Декларативная парадигма возможна не только в программировании, но и в самом подходе. Это нам доказывает набирающий популярность пакетный менеджер Nix и операционная система NixOS. И этот подход очень даже удобен, но в нем надо разобраться. Самое банальное — в Nix мы не пишем команду для установки нужного пакета и его зависимостей, а записываем его в конфигурацию. Более наглядно можно продемонстрировать на примере редактора VS Code. В NixOS нам не обязательно сначала устанавливать его, а потом насыщать его расширениями вручную — мы можем сразу в конфигурацию добавить нужные официальные расширения и расширения из маркетплейса.

У декларативной парадигмы также есть направления:

1. Функциональное. Самое явное направление. Ближайший пример — Haskell. В строгом функциональном подходе считается, что все функции чистые и не имеют побочных эффектов. Минус побочных эффектов в том, что их сложно учитывать. В функциональных языках побочных эффектов нет, поэтому нет и понятия изменения объектов. Функция не меняет старый объект, а возвращает новый.
2. Логическое программирование. Задачи решаются путём формулировки утверждений и правил, из которых система выводит результат. Относится к категории забытых, т.к. не сыскало большой популярности.

Язык программирования должен иметь свою парадигму и направление.

Можно также задать некие правила, "дзен" вашего языка. В моем случае это будет универсальность, как в языке Ruby — "есть несколько способов сделать это".

Также, язык программирования может быть компилируемым или интерпретируемым. Опустим описание, надеюсь что вы знаете чем они отличаются. Мы изберем популярный способ - компилируемый язык программирования. Компилятор будет реализован на C++ с применением LLVM. Что это такое, и их каких этапов состоит компиляция, я опишу в следующих главах.

Я решил попробовать следовать функционально-процедурной парадигме. Мой язык - SLEAF - будет низкоуровневый.

# Что такое LLVM?
LLVM - это целый набор инструментов для создании и оптимизации компиляторов. Он позволяет даже создавать языки программирования с нуля.

 > LLVM создан в 2003 году аспирантом Крисом Латтнером. В настоящий день LLVM используется для Rust, Swift, Julia.

LLVM берет на себя сложный процесс преобразования исходного кода в машинный код. Самое главное, чем занимается LLVM - это превращение исходного кода высокого уровня в код, который не зависит от языка, называемый IR.

Это означает, что совершенно два разных языка - например Cuda и Ruby - создают один и тот же код IR, что позволяет им использовать инструменты анализа и оптимизации от LLVM, прежде чем они будут преобразованы в машинный код конкретной архитектуры.

# Источники

 + ["Забытые" парадигмы программирования](https://habr.com/ru/articles/223253/)
 + [Парадигмы программирования](https://practicum.yandex.ru/blog/paradigmy-programmirovaniya/)
